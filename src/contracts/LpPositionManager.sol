// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import {BalanceDelta} from '@uniswap/v4-core/src/types/BalanceDelta.sol';
import {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from '@uniswap/v4-core/src/types/BeforeSwapDelta.sol';
import {Currency} from '@uniswap/v4-core/src/types/Currency.sol';
import {Hooks, IHooks} from '@uniswap/v4-core/src/libraries/Hooks.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';
import {PoolId, PoolIdLibrary} from '@uniswap/v4-core/src/types/PoolId.sol';
import {PoolKey} from '@uniswap/v4-core/src/types/PoolKey.sol';
import {SafeCast} from '@uniswap/v4-core/src/libraries/SafeCast.sol';
import {StateLibrary} from '@uniswap/v4-core/src/libraries/StateLibrary.sol';

import {BaseHook} from '@uniswap-periphery/base/hooks/BaseHook.sol';

import {BidWall} from '@flaunch/bidwall/BidWall.sol';
import {CurrencySettler} from '@flaunch/libraries/CurrencySettler.sol';
import {FairLaunch} from '@flaunch/hooks/FairLaunch.sol';
import {FeeDistributor} from '@flaunch/hooks/FeeDistributor.sol';
import {FeeExemptions} from '@flaunch/hooks/FeeExemptions.sol';
import {InternalSwapPool} from '@flaunch/hooks/InternalSwapPool.sol';
import {MemecoinFinder} from '@flaunch/types/MemecoinFinder.sol';
import {MemecoinTreasury} from '@flaunch/treasury/MemecoinTreasury.sol';
import {Notifier} from '@flaunch/hooks/Notifier.sol';
import {StoreKeys} from '@flaunch/types/StoreKeys.sol';
import {TreasuryActionManager} from '@flaunch/treasury/ActionManager.sol';
import {UniswapHookEvents} from '@flaunch/libraries/UniswapHookEvents.sol';
import {FlaunchLPManager} from '@flaunch/FlaunchLpManager.sol';

import {IFeeCalculator} from '@flaunch-interfaces/IFeeCalculator.sol';
import {IAnyFlaunch} from '@flaunch-interfaces/IAnyFlaunch.sol';
import {IInitialPrice} from '@flaunch-interfaces/IInitialPrice.sol';


/**
 * The AnyPositionManager is a Uniswap V4 hook enables any ERC20 token to have BidWall and distribute fees with the community.
 *
 * The creator of the pool will receive an ERC721 representation of the token. The holder of
 * this token will be the recipient of any creator fees generated by the token in the pool.
 *
 * Hook interactions have aimed to be abstracted into inherited contracts to simplify both
 * functionality and readability. Specific use of each of these contracts has been denoted
 * within comments using square brackets where possible.
 */
contract LpPositionManager is BaseHook, FeeDistributor, InternalSwapPool, StoreKeys {

    using BeforeSwapDeltaLibrary for BeforeSwapDelta;
    using CurrencySettler for Currency;
    using PoolIdLibrary for PoolKey;
    using SafeCast for uint;
    using StateLibrary for IPoolManager;
    using MemecoinFinder for PoolKey;

    error AlreadyFlaunched();
    error CallerIsNotBidWall();
    error CannotBeInitializedDirectly();
    error UnknownPool(PoolId _poolId);
    error CallerIsNotApprovedCreator();

    // Event for LP manager updates
    event LPManagerUpdated(address indexed newLPManager);

    /// Emitted when a creator is approved to flaunch
    event CreatorApproved(address _creator, bool _isApproved);

    /// Emitted when a Flaunch pool is created
    event PoolCreated(PoolId indexed _poolId, address _memecoin, address _memecoinTreasury, uint _tokenId, bool _currencyFlipped, FlaunchParams _params);

    /// Emitted when a pool swap occurs
    event PoolSwap(PoolId indexed poolId, int flAmount0, int flAmount1, int flFee0, int flFee1, int ispAmount0, int ispAmount1, int ispFee0, int ispFee1, int uniAmount0, int uniAmount1, int uniFee0, int uniFee1);

    /// Emitted after any transaction to share pool state
    event PoolStateUpdated(PoolId indexed _poolId, uint160 _sqrtPriceX96, int24 _tick, uint24 _protocolFee, uint24 _swapFee, uint128 _liquidity);

    /// Emitted when the `IInitialPrice` contract has been updated
    event InitialPriceUpdated(address _initialPrice);

    /**
     * Defines our constructor parameters.
     *
     * @member nativeToken The native ETH equivalent token used by protocol
     * @member poolManager The Uniswap V4 {PoolManager} contract
     * @member feeDistribution The default fee distribution configuration
     * @member initialPrice Set initial price calculator address
     * @member protocolOwner The EOA that will be the initial owner
     * @member protocolFeeRecipient The recipient EOA of all
     * @member flayGovernance The $FLAY token governance address
     * @member feeEscrow The {FeeEscrow} contract to be used by the PositionManager
     * @member feeExemptions The default global FeeExemption values
     * @member actionManager The {TreasuryActionManager} contract
     * @member bidWall The {BidWall} contract to be used by the PositionManager
     */
    struct ConstructorParams {
        address nativeToken;
        IPoolManager poolManager;
        FeeDistribution feeDistribution;
        IInitialPrice initialPrice;
        address protocolOwner;
        address protocolFeeRecipient;
        address flayGovernance;
        address feeEscrow;
        FeeExemptions feeExemptions;
        TreasuryActionManager actionManager;
        address bidWall;
    }

    /**
     * Parameters required when adding an existing token to flaunch.
     *
     * @member memecoin The address of the ERC20 token
     * @member creator The address that will receive the ERC721 ownership and premined ERC20 tokens
     * @member creatorFeeAllocation The percentage of fees the creators wants to take from the BidWall
     * @member initialPriceParams The encoded parameters for the Initial Price logic
     * @member feeCalculatorParams The encoded parameters for the fee calculator
     */
    struct FlaunchParams {
        address memecoin;
        address creator;
        uint24 creatorFeeAllocation;
        bytes initialPriceParams;
        bytes feeCalculatorParams;
    }

    // LP manager contract that will be used to manage liquidity providers
    FlaunchLPManager public lpManager;

    /// The minimum amount before a distribution is triggered
    uint public constant MIN_DISTRIBUTE_THRESHOLD = 0.001 ether;

    /// The contract that will be used for flaunching tokens
    IAnyFlaunch public flaunchContract;

    /// Our starting token sqrtPriceX96
    IInitialPrice public initialPrice;

    /// Internal storage to allow the `beforeSwap` tick value to be used in `afterSwap`
    int24 internal _beforeSwapTick;

    /// Store the address that will collect protocol fees
    address internal protocolFeeRecipient;

    /// Store the contract that will manage our Bidwall interactions
    BidWall public bidWall;

    /// The contract that handles the token Treasury actions
    TreasuryActionManager public actionManager;

    /// Store the contract that will manage fee exemptions
    FeeExemptions public feeExemptions;

    /// Store our {Notifier} contract
    Notifier public notifier;

    /// Stores the approved memecoin creators
    mapping(address _creator => bool isApproved) public approvedMemecoinCreator;

    /**
     * Initializes our {BaseHook} contract and initializes all implemented hooks.
     */
    constructor (ConstructorParams memory params)
        BaseHook(params.poolManager)
        FeeDistributor(params.nativeToken, params.feeDistribution, params.protocolOwner, params.flayGovernance, params.feeEscrow)
    {
        // Set our contract references
        initialPrice = params.initialPrice;

        // Set our protocol fee recipient
        protocolFeeRecipient = params.protocolFeeRecipient;

        // Register our FeeExemption contract
        feeExemptions = params.feeExemptions;

        // Register our BidWall contract
        bidWall = BidWall(params.bidWall);

        // Register our ActionManager
        actionManager = params.actionManager;

        // Deploy our notifier
        notifier = new Notifier(params.protocolOwner);

        // Approve the BidWall to manage native token from the PositionManager
        IERC20(params.nativeToken).approve(address(bidWall), type(uint).max);
    }

    /**
     * Adds an existing ERC20 token to the flaunch contract, creating an ERC721 that signifies ownership of the
     * flaunched collection. The token is then initialized into a UV4 pool.
     * 
     * @dev Can only be called by the owner, to prevent duplicate poolKeys
     */
    function flaunch(FlaunchParams calldata _params) external {
        // allow only the approved creators to flaunch
        if (!approvedMemecoinCreator[msg.sender]) revert CallerIsNotApprovedCreator();

        if (flaunchContract.tokenId(_params.memecoin) != 0) revert AlreadyFlaunched();

        // add the memecoin to the flaunch contract
        (address payable memecoinTreasury, uint tokenId) = flaunchContract.flaunch(_params);

        // Check if our pool currency is flipped
        bool currencyFlipped = nativeToken >= _params.memecoin;

        // Create our Uniswap pool and store the pool key for lookups
        PoolKey memory _poolKey = PoolKey({
            currency0: Currency.wrap(!currencyFlipped ? nativeToken : _params.memecoin),
            currency1: Currency.wrap(currencyFlipped ? nativeToken : _params.memecoin),
            fee: 0,
            tickSpacing: 60,
            hooks: IHooks(address(this))
        });

        // Initialize the {MemecoinTreasury} with `PoolKey`
        MemecoinTreasury(memecoinTreasury).initialize(payable(address(this)), address(actionManager), nativeToken, _poolKey);

        // Set the PoolKey to storage
        _poolKeys[_params.memecoin] = _poolKey;
        PoolId poolId = _poolKey.toId();

        // If we have a non-zero creator fee allocation, then we need to update our creator's
        // fee allocation.
        if (_params.creatorFeeAllocation != 0) {
            creatorFee[poolId] = _params.creatorFeeAllocation;
        }

        // Initialize our memecoin with the sqrtPriceX96
        poolManager.initialize(
            _poolKey,
            initialPrice.getSqrtPriceX96(msg.sender, currencyFlipped, _params.initialPriceParams)
        );

        emit PoolCreated({
            _poolId: poolId,
            _memecoin: _params.memecoin,
            _memecoinTreasury: memecoinTreasury,
            _tokenId: tokenId,
            _currencyFlipped: currencyFlipped,
            _params: _params
        });

        // After our contract is initialized, we mark our pool as initialized and emit
        // our state update to notify the UX of current prices, etc.
        _emitPoolStateUpdate(poolId, IHooks.afterInitialize.selector, abi.encode(tokenId, _params));
    }

    /**
     * Returns the PoolKey mapped to the token address. If none is set then a zero value
     * will be returned for the fields.
     *
     * @dev The easiest way to check for an empty response is `tickSpacing = 0`
     *
     * @param _token The address of the ERC20 token
     *
     * @return The corresponding {PoolKey} for the token
     */
    function poolKey(address _token) external view returns (PoolKey memory) {
        return _poolKeys[_token];
    }

    /**
     * Defines the Uniswap V4 hooks that are used by our implementation. This will determine
     * the address that our contract **must** be deployed to for Uniswap V4. This address suffix
     * is shown in the dev comments for this function call.
     *
     * @dev 1001 0111 0111 00 == 25DC
     */
    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: true, // Prevent initialize
            afterInitialize: false,
            beforeAddLiquidity: false,
            afterAddLiquidity: true, // [EventTracking]
            beforeRemoveLiquidity: false,
            afterRemoveLiquidity: true, // [EventTracking]
            beforeSwap: true, // [InternalSwapPool]
            afterSwap: true, // [FeeDistributor], [InternalSwapPool], [BidWall], [EventTracking]
            beforeDonate: false,
            afterDonate: true, // [EventTracking]
            beforeSwapReturnDelta: true, // [InternalSwapPool]
            afterSwapReturnDelta: true, // [FeeDistributor]
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    /**
     * The hook called before the state of a pool is initialized. Prevents external contracts
     * from initializing pools using our contract as a hook.
     *
     * @dev As we call `poolManager.initialize` from the IHooks contract itself, we bypass this
     * hook call therefore bypassing the prevention.
     */
    function beforeInitialize(address, PoolKey calldata, uint160) external view override onlyPoolManager returns (bytes4) {
        revert CannotBeInitializedDirectly();
    }

    /**
     * [ISP] Checks if we can process an internal swap ahead of the Uniswap swap.
     * [FD] Captures fees from the internal swap pool
     *
     * @param _sender The address calling the swap
     * @param _key The key for the pool
     * @param _params The parameters for the swap
     * @param _hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook
     *
     * @return selector_ The function selector for the hook
     * @return beforeSwapDelta_ The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     * @return swapFee_ The percentage fee applied to our swap
     */
    function beforeSwap(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.SwapParams memory _params,
        bytes calldata _hookData
    ) public override onlyPoolManager returns (
        bytes4 selector_,
        BeforeSwapDelta beforeSwapDelta_,
        uint24
    ) {
        /**
         * [ISP] We want to see if we have any token1 fee tokens that we can use to fill the swap
         * before it hits the Uniswap pool. This prevents the pool from being affected and reduced
         * gas costs. This also allows us to benefit from the Uniswap routing infrastructure.
         *
         * This frontruns Uniswap to sell undesired token amounts from our fees into desired tokens
         * ahead of our fee distribution. This acts as a partial orderbook to remove impact against
         * our pool.
         */

        bool nativeIsZero = nativeToken == Currency.unwrap(_key.currency0);
        (uint tokenIn, uint tokenOut) = _internalSwap(poolManager, _key, _params, nativeIsZero);
        if (tokenIn + tokenOut != 0) {
            // Update our hook delta to reduce the upcoming swap amount to show that we have
            // already spent some of the ETH and received some of the underlying ERC20.
            BeforeSwapDelta internalBeforeSwapDelta = _params.amountSpecified >= 0
                ? toBeforeSwapDelta(-tokenOut.toInt128(), tokenIn.toInt128())
                : toBeforeSwapDelta(tokenIn.toInt128(), -tokenOut.toInt128());

            /**
             * [FD] We need to determine the amount of fees generated by our internal swap to capture,
             * rather than sending the full amount to the end user.
             */

            // We need to capture fees from our internal swap at this point
            uint swapFee = _captureAndDepositFees(_key, _params, _sender, internalBeforeSwapDelta.getUnspecifiedDelta(), _hookData);

            // Increment our swap
            _captureDelta(_params, TS_ISP_AMOUNT0, TS_ISP_AMOUNT1, internalBeforeSwapDelta);
            _captureDeltaSwapFee(_params, TS_ISP_FEE0, TS_ISP_FEE1, swapFee);

            // Increase the delta being sent back
            beforeSwapDelta_ = toBeforeSwapDelta(
                beforeSwapDelta_.getSpecifiedDelta() + internalBeforeSwapDelta.getSpecifiedDelta(),
                beforeSwapDelta_.getUnspecifiedDelta() + internalBeforeSwapDelta.getUnspecifiedDelta() + swapFee.toInt128()
            );
        }

        // Capture the beforeSwap tick value before actioning our Uniswap swap
        (, _beforeSwapTick,,) = poolManager.getSlot0(_key.toId());

        // Check if the BidWall has become stale, and allow liquidity to be extracted before a
        // threshold has been built.
        bidWall.checkStalePosition({
            _poolKey: _key,
            _currentTick: _beforeSwapTick,
            _nativeIsZero: nativeIsZero
        });

        // Set our return selector
        selector_ = IHooks.beforeSwap.selector;
    }

    /**
     * [FD] Captures fees from the swap to either distribute or send to ISP
     * [ISP] Once a swap has been made, we distribute fees to our LPs and emit our price update event.
     * [FD] Tracks the swap for future fee calculations
     *
     * @param _sender The sender (or swap contract) making the call
     * @param _key The key for the pool
     * @param _params The parameters for the swap
     * @param _delta The amount owed to the caller (positive) or owed to the pool (negative)
     * @param _hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook
     *
     * @return selector_ The function selector for the hook
     * @return hookDeltaUnspecified_ The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     */
    function afterSwap(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.SwapParams calldata _params,
        BalanceDelta _delta,
        bytes calldata _hookData
    ) public override onlyPoolManager returns (
        bytes4 selector_,
        int128 hookDeltaUnspecified_
    ) {
        /**
         * [FD] We need to determine the amount of fees generated by our Uniswap swap to capture,
         * rather than sending the full amount to the end user.
         */

        // Determine the currency that we will be taking our fee from
        (int128 amount0, int128 amount1) = (_delta.amount0(), _delta.amount1());
        int128 swapAmount = _params.amountSpecified < 0 == _params.zeroForOne ? amount1 : amount0;

        // Capture the swap fees and dispatch the referrer's share if set
        uint swapFee = _captureAndDepositFees(_key, _params, _sender, swapAmount, _hookData);

        // Increment our swap
        assembly {
            tstore(TS_UNI_AMOUNT0, amount0)
            tstore(TS_UNI_AMOUNT1, amount1)
        }

        _captureDeltaSwapFee(_params, TS_UNI_FEE0, TS_UNI_FEE1, swapFee);

        /**
         * [ISP] Distribute any fees that have been converted by the swap.
         */

        _distributeFees(_key);

        /**
         * [FD] If we have a feeCalculator, then we want to track the swap data for any
         * dynamic calculations.
         */

        PoolId poolId = _key.toId();

        {
            IFeeCalculator _feeCalculator = getFeeCalculator({_isFairLaunch: false});
            if (address(_feeCalculator) != address(0)) {
                _feeCalculator.trackSwap(_sender, _key, _params, _delta, _hookData);
            }
        }

        // Set our return selector
        hookDeltaUnspecified_ = swapFee.toInt128();

        selector_ = IHooks.afterSwap.selector;

        // Emit our compiled swap data
        _emitSwapUpdate(poolId, _sender);

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(poolId, selector_, abi.encode(_sender, _params, _delta));
    }

    /**
     * Once a liquidity has been added, we emit our price update event.
     *
     * @param _sender The initial msg.sender for the add liquidity call
     * @param _key The key for the pool
     * @param _delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta
     * @param _feesAccrued The fees accrued since the last time fees were collected from this position
     *
     * @return selector_ The function selector for the hook
     * @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     */
    function afterAddLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        BalanceDelta _delta,
        BalanceDelta _feesAccrued,
        bytes calldata
    ) external override onlyPoolManager returns (
        bytes4 selector_,
        BalanceDelta
    ) {
        selector_ = IHooks.afterAddLiquidity.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _delta, _feesAccrued));
    }

    /**
     * Once liquidity has been removed, we emit our price update event.
     *
     * @param _sender The initial msg.sender for the remove liquidity call
     * @param _key The key for the pool
     * @param _delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta
     * @param _feesAccrued The fees accrued since the last time fees were collected from this position
     *
     * @return selector_ The function selector for the hook
     */
    function afterRemoveLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        BalanceDelta _delta,
        BalanceDelta _feesAccrued,
        bytes calldata
    ) public override onlyPoolManager returns (bytes4 selector_, BalanceDelta) {
        selector_ = IHooks.afterRemoveLiquidity.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _delta, _feesAccrued));
    }

    /**
     * Allows the owner to set the LP manager contract address.
     *
     * @param _lpManager The address of the new LP manager contract
     */
    function setLPManager(address _lpManager) external onlyOwner {
        lpManager = FlaunchLPManager(_lpManager);
        
        // Approve FLETH for the LP manager to pull tokens
        IERC20(nativeToken).approve(address(lpManager), type(uint).max);
        
        emit LPManagerUpdated(_lpManager);
    }

    /**
     * The hook called after donate, emitting our price update event.
     *
     * @param _sender The initial msg.sender for the donate call
     * @param _key The key for the pool
     * @param _amount0 The amount of token0 being donated
     * @param _amount1 The amount of token1 being donated
     *
     * @return selector_ The function selector for the hook
     */
    function afterDonate(address _sender, PoolKey calldata _key, uint _amount0, uint _amount1, bytes calldata) external override onlyPoolManager returns (bytes4 selector_) {
        selector_ = IHooks.afterDonate.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _amount0, _amount1));
    }

    /**
     * Gets the ETH market cap for a new token that will be flaunched.
     *
     * @return The ETH market cap value
     */
    function getFlaunchingMarketCap(bytes calldata _initialPriceParams) public view returns (uint) {
        return initialPrice.getMarketCap(_initialPriceParams);
    }

    /**
     * Allows the contract used to flaunch a new token to be updated.
     *
     * @param _flaunchContract The new {IAnyFlaunch} contract address
     */
    function setFlaunch(address _flaunchContract) public onlyOwner {
        flaunchContract = IAnyFlaunch(_flaunchContract);
    }

    /**
     * Allows the creator of a memecoin to be approved to flaunch.
     * 
     * @dev Only callable by the owner
     *
     * @param _creator The creator to approve
     * @param _isApproved Whether the creator is approved
     */
    function approveCreator(address _creator, bool _isApproved) public onlyOwner {
        approvedMemecoinCreator[_creator] = _isApproved;
        emit CreatorApproved(_creator, _isApproved);
    }

    /**
     * Updates the `IInitialPrice` contract address that is used during `flaunch` to calculate
     * the initial tick / sqrtPriceX96 value.
     *
     * @param _initialPrice The contract address for the `IInitialPrice` contract
     */
    function setInitialPrice(address _initialPrice) public onlyOwner {
        initialPrice = IInitialPrice(_initialPrice);
        emit InitialPriceUpdated(_initialPrice);
    }

    /**
     * Calls for the BidWall to be closed, as this requires callback from the {PoolManager}.
     */
    function closeBidWall(PoolKey memory _key) public {
        // Ensure that the call is made by the BidWall which validates logic
        if (msg.sender != address(bidWall)) revert CallerIsNotBidWall();

        // Ensure that the PoolKey that is being closed is valid and recognised on the protocol,
        // otherwise we could processing issues and false positives in upcoming steps. We need to
        // ensure that the PoolKey is recognised (by checking the hooks address is not zero) and
        // that the PoolId matches when encoded.
        PoolKey memory storedKey = _poolKeys[address(_key.memecoin(nativeToken))];
        if (storedKey.hooks == IHooks(address(0)) || PoolId.unwrap(storedKey.toId()) != PoolId.unwrap(_key.toId())) {
            revert UnknownPool(_key.toId());
        }

        // Action our BidWall closure via the {PoolManager} unlock
        poolManager.unlock(abi.encode(_key));
    }

    /**
     * This function should only be called by the `closeBidWall` function to unlock the {PoolManager}
     * interactions for the `{BidWall}.closeBidWall` function.
     *
     * @param _data The encoded {PoolKey} for the `closeBidWall` request
     *
     * @return bytes Empty data; nothing will be returned
     */
    function _unlockCallback(bytes calldata _data) internal override returns (bytes memory) {
        bidWall.closeBidWall(abi.decode(_data, (PoolKey)));
    }

    /**
     * Capture the fees from our swap. This could either be from an internal swap (`beforeSwap`)
     * or from the actual Uniswap swap (`afterSwap`).
     *
     * @dev This is only used due to too many variables in the `beforeSwap` function
     *
     * @param _key The {PoolKey} that the swap was made against
     * @param _params The swap parameters called in the swap
     * @param _sender The sender of the swap call
     * @param _delta The balance change from the swap
     * @param _hookData Additional bytes data passed in the swap
     *
     * @return swapFee_ The fee taken from the swap
     */
    function _captureAndDepositFees(
        PoolKey calldata _key,
        IPoolManager.SwapParams memory _params,
        address _sender,
        int128 _delta,
        bytes calldata _hookData
    ) internal returns (uint swapFee_) {
        // Determine the swap fee currency based on swap parameters
        Currency swapFeeCurrency = _params.amountSpecified < 0 == _params.zeroForOne ? _key.currency1 : _key.currency0;

        // Capture our swap fees amount
        swapFee_ = _captureSwapFees({
            _poolManager: poolManager,
            _key: _key,
            _params: _params,
            _feeCalculator: getFeeCalculator({_isFairLaunch: false}),
            _swapFeeCurrency: swapFeeCurrency,
            _swapAmount: uint128(_delta < 0 ? -_delta : _delta),
            _feeExemption: feeExemptions.feeExemption(_sender)
        });

        // If we have no swap fees, then we have nothing to process
        if (swapFee_ == 0) {
            return swapFee_;
        }

        // Check if we have a referrer set and send them the currency directly
        uint referrerFee = _distributeReferrerFees({
            _key: _key,
            _swapFeeCurrency: swapFeeCurrency,
            _swapFee: swapFee_,
            _hookData: _hookData
        });

        // Deposit the remaining fees against our pool to be either distributed to
        // others, or placed into the Internal Swap Pool to be converted into an ETH
        // equivalent token. We don't reduce the amount by referrer fees as we still
        // need to claim this from the PoolManager.
        _depositFees(
            _key,
            Currency.unwrap(swapFeeCurrency) == nativeToken ? swapFee_ - referrerFee : 0,
            Currency.unwrap(swapFeeCurrency) == nativeToken ? 0 : swapFee_ - referrerFee
        );
    }

    // Function to configure LP pools in Uniswap V4
    function configureLPPool(
        PoolKey calldata _poolKey,
        int24 _tickLower,
        int24 _tickUpper
    ) external onlyOwner {
        require(address(lpManager) != address(0), "LP Manager not set");
        lpManager.configurePool(_poolKey, _tickLower, _tickUpper);
    }

    /**
     * We want to be able to distribute fees across our {FeeDistribution} recipients
     * when we reach a set threshold. This will only ever distribute the ETH equivalent
     * token, as the non-ETH token will be converted via the {InternalSwapPool} hook logic.
     *
     * @dev There referrer has already received their share, so they do not need to be
     * taken into account at this point.
     *
     * @param _poolKey The PoolKey reference that will have fees distributed
     */
    function _distributeFees(PoolKey memory _poolKey) internal {
    PoolId poolId = _poolKey.toId();

    // Get the amount of FLETH available to distribute
    uint distributeAmount = _poolFees[poolId].amount0;

    // Ensure that the collection has sufficient fees available
    if (distributeAmount < MIN_DISTRIBUTE_THRESHOLD) return;

    // Reduce our available fees for the pool
    _poolFees[poolId].amount0 = 0;

    // Get fee split: expecting protocolFee = 0, lpFee = 90%, bidWallFee = 10%
    (uint bidWallFee, uint lpFee, uint protocolFee) = feeSplit(poolId, distributeAmount);

    // Load our memecoin
    address memecoin = address(_poolKey.memecoin(nativeToken));

    // Check if our creator has been burned
    address poolCreator = flaunchContract.creator(memecoin);
    bool poolCreatorBurned = poolCreator == address(0);

    // Handle LP fees (90% of total)
    if (lpFee != 0 && address(lpManager) != address(0)) {
        // Just call receiveFeesToken - LP manager will pull the tokens
        lpManager.receiveFeesToken(memecoin, lpFee);
    }

    // Handle BidWall fees (10% of total)
    if (bidWallFee != 0) {
        // Check if we have an active BidWall for the pool
        if (bidWall.isBidWallEnabled(poolId)) {
            bidWall.deposit(_poolKey, bidWallFee, _beforeSwapTick, nativeToken == Currency.unwrap(_poolKey.currency0));
        } else {
            // If BidWall is disabled and creator not burned, add to LP fees
            if (!poolCreatorBurned && address(lpManager) != address(0)) {
                lpManager.receiveFeesToken(memecoin, bidWallFee);
            } else {
                // Last resort: send to protocol
                protocolFee += bidWallFee;
            }
            bidWallFee = 0;
        }
    }

    // Protocol fees (should be 0 based on your requirements)
    if (protocolFee != 0) {
        _allocateFees(poolId, protocolFeeRecipient, protocolFee);
    }

    emit PoolFeesDistributed(poolId, distributeAmount, lpFee, bidWallFee, 0, protocolFee);
    }

    /**
     * Using the `tstore` values that we have generated along the way, we emit an event that shows
     * the breakdown of fees earned at each swap point.
     *
     * @param _poolId The PoolId that is being emitted
     * @param _sender The router of the swap
     */
    function _emitSwapUpdate(PoolId _poolId, address _sender) internal {
        // Emit our protocol-recognised event
        emit PoolSwap(
            _poolId,
            0, 0, 0, 0,
            _tload(TS_ISP_AMOUNT0), _tload(TS_ISP_AMOUNT1), _tload(TS_ISP_FEE0), _tload(TS_ISP_FEE1),
            _tload(TS_UNI_AMOUNT0), _tload(TS_UNI_AMOUNT1), _tload(TS_UNI_FEE0), _tload(TS_UNI_FEE1)
        );

        // Emit the Uniswap V4 standardised event. We have no FairLaunch related amounts or fees,
        // so we can just send the ISP amounts directly.
        UniswapHookEvents.emitHookSwapEvent({
            _poolId: _poolId,
            _sender: _sender,
            _amount0: _tload(TS_ISP_AMOUNT0),
            _amount1: _tload(TS_ISP_AMOUNT1),
            _fee0: _tload(TS_ISP_FEE0),
            _fee1: _tload(TS_ISP_FEE1)
        });

        // @dev We flush the tstore values at this point as although they are only set
        // explicitly and not modified, the ISP could be bypassed but the tstore data would remain.

        assembly {
            tstore(TS_ISP_AMOUNT0, 0)
            tstore(TS_ISP_AMOUNT1, 0)
            tstore(TS_ISP_FEE0, 0)
            tstore(TS_ISP_FEE1, 0)
            tstore(TS_UNI_AMOUNT0, 0)
            tstore(TS_UNI_AMOUNT1, 0)
            tstore(TS_UNI_FEE0, 0)
            tstore(TS_UNI_FEE1, 0)
        }
    }

    /**
     * Emits an event that provides pool state updates and passes the data to subscribers.
     *
     * @param _poolId The PoolId that has been updated
     * @param _key The selector being sent to notification subscribers
     * @param _data The data being sent to notification subscribers
     */
    function _emitPoolStateUpdate(PoolId _poolId, bytes4 _key, bytes memory _data) internal {
        // Notify our subscribed contracts
        notifier.notifySubscribers(_poolId, _key, _data);

        // Emit our event
        (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 swapFee) = poolManager.getSlot0(_poolId);
        emit PoolStateUpdated(_poolId, sqrtPriceX96, tick, protocolFee, swapFee, poolManager.getLiquidity(_poolId));
    }

    /**
     * Settles tokens against the PoolManager based on the BalanceDelta passed.
     *
     * @dev This is required to be separated due to Stack Too Deep errors
     *
     * @param _poolKey The pool key to settle against
     * @param _delta The BalanceDelta showing token amounts to settle
     */
    function _settleDelta(PoolKey memory _poolKey, BalanceDelta _delta) internal {
        if (_delta.amount0() < 0) {
            _poolKey.currency0.settle(poolManager, address(this), uint(-int(_delta.amount0())), false);
        } else if (_delta.amount0() > 0) {
            poolManager.take(_poolKey.currency0, address(this), uint(int(_delta.amount0())));
        }

        if (_delta.amount1() < 0) {
            _poolKey.currency1.settle(poolManager, address(this), uint(-int(_delta.amount1())), false);
        } else if (_delta.amount1() > 0) {
            poolManager.take(_poolKey.currency1, address(this), uint(int(_delta.amount1())));
        }
    }

    /**
     * We need to be able to set the (un)specified token to amount0 / amount1 for the expected
     * event emit format.
     *
     * @param _params The `SwapParams` used to capture the delta
     * @param _key_amount0 The tstore key for the token0 amount
     * @param _key_amount1 The tstore key for the token1 amount
     * @param _delta The `BeforeSwapDelta` that is being captured
     */
    function _captureDelta(
        IPoolManager.SwapParams memory _params,
        bytes32 _key_amount0,
        bytes32 _key_amount1,
        BeforeSwapDelta _delta
    ) internal {
        (int token0, int token1) = _params.amountSpecified < 0 == _params.zeroForOne
            ? (-_delta.getSpecifiedDelta(), -_delta.getUnspecifiedDelta())
            : (-_delta.getUnspecifiedDelta(), -_delta.getSpecifiedDelta());

        // Store our amounts
        assembly {
            tstore(_key_amount0, token0)
            tstore(_key_amount1, token1)
        }
    }

    /**
     * Maps our swap fee to the expected event emit format.
     *
     * @param _params The `SwapParams` used to capture the delta
     * @param _key_fee0 The tstore key for the token0 fee amount
     * @param _key_fee1 The tstore key for the token1 fee amount
     * @param _delta The `uint` that is being captured for the fee
     */
    function _captureDeltaSwapFee(
        IPoolManager.SwapParams memory _params,
        bytes32 _key_fee0,
        bytes32 _key_fee1,
        uint _delta
    ) internal {
        // The delta provided needs to be made negative
        int delta = -int(_delta);

        if (_params.amountSpecified < 0 == _params.zeroForOne) {
            assembly {
                tstore(_key_fee0, 0)
                tstore(_key_fee1, delta)
            }
        } else {
            assembly {
                tstore(_key_fee0, delta)
                tstore(_key_fee1, 0)
            }
        }
    }

    /**
     * Helper function to allow for tstore-d variables to be called individually. This saves us
     * defining an additional variable before our `tload` calls inside the function.
     *
     * @param _key The `tstore` key to load
     *
     * @return value_ The `int` value in the tstore
     */
    function _tload(bytes32 _key) internal view returns (int value_) {
        assembly { value_ := tload(_key) }
    }

    /**
     * Override to return true to make `_initializeOwner` prevent double-initialization.
     *
     * @return bool Set to `true` to prevent owner being reinitialized.
     */
    function _guardInitializeOwner() internal pure override returns (bool) {
        return true;
    }

}
